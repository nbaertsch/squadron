<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Squadron Dashboard</title>
    <style>
        :root {
            --bg-primary: #0d1117;
            --bg-secondary: #161b22;
            --bg-tertiary: #21262d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-muted: #484f58;
            --border: #30363d;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-red: #f85149;
            --accent-yellow: #d29922;
            --accent-purple: #a371f7;
            --accent-cyan: #39c5cf;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", "Noto Sans", Helvetica, Arial, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.5;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 20px;
            border-bottom: 1px solid var(--border);
            margin-bottom: 20px;
        }

        h1 {
            font-size: 24px;
            font-weight: 600;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--accent-red);
        }

        .status-dot.connected {
            background: var(--accent-green);
        }

        .controls-bar {
            display: flex;
            gap: 16px;
            margin-bottom: 20px;
            flex-wrap: wrap;
            align-items: center;
        }

        .control-group {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-group label {
            font-size: 13px;
            color: var(--text-secondary);
        }

        .grid {
            display: grid;
            grid-template-columns: 300px 1fr;
            gap: 20px;
        }

        .panel {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            overflow: hidden;
        }

        .panel-header {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            font-weight: 600;
            font-size: 14px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .panel-content {
            padding: 16px;
        }

        .agent-list {
            list-style: none;
            max-height: 500px;
            overflow-y: auto;
        }

        .agent-item {
            padding: 12px;
            border-bottom: 1px solid var(--border);
            cursor: pointer;
            transition: background 0.15s;
        }

        .agent-item:last-child {
            border-bottom: none;
        }

        .agent-item:hover {
            background: var(--bg-tertiary);
        }

        .agent-item.selected {
            background: var(--bg-tertiary);
            border-left: 3px solid var(--accent-blue);
        }

        .agent-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 4px;
        }

        .agent-id {
            font-family: ui-monospace, SFMono-Regular, "SF Mono", Menlo, monospace;
            font-size: 13px;
            color: var(--accent-blue);
        }

        .agent-status {
            font-size: 11px;
            padding: 2px 8px;
            border-radius: 12px;
            text-transform: uppercase;
            font-weight: 500;
        }

        .status-active { background: rgba(63, 185, 80, 0.2); color: var(--accent-green); }
        .status-sleeping { background: rgba(210, 153, 34, 0.2); color: var(--accent-yellow); }
        .status-completed { background: rgba(88, 166, 255, 0.2); color: var(--accent-blue); }
        .status-escalated { background: rgba(248, 81, 73, 0.2); color: var(--accent-red); }
        .status-failed { background: rgba(248, 81, 73, 0.2); color: var(--accent-red); }

        .agent-meta {
            font-size: 12px;
            color: var(--text-secondary);
        }

        .activity-feed {
            height: 700px;
            overflow-y: auto;
        }

        .activity-item {
            padding: 12px 16px;
            border-bottom: 1px solid var(--border);
            font-size: 13px;
        }

        .activity-item:last-child {
            border-bottom: none;
        }

        .activity-item.expanded .activity-details {
            display: block;
        }

        .activity-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            cursor: pointer;
        }

        .activity-type {
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .activity-type-icon {
            width: 20px;
            height: 20px;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 11px;
            font-weight: bold;
        }

        .icon-tool { background: var(--accent-purple); }
        .icon-lifecycle { background: var(--accent-blue); }
        .icon-github { background: #333; }
        .icon-circuit { background: var(--accent-yellow); }
        .icon-error { background: var(--accent-red); }
        .icon-info { background: var(--accent-cyan); }
        .icon-reasoning { background: var(--accent-green); }

        .activity-time {
            font-size: 11px;
            color: var(--text-muted);
        }

        .activity-summary {
            color: var(--text-secondary);
            word-break: break-word;
        }

        .activity-summary code {
            background: var(--bg-tertiary);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: ui-monospace, SFMono-Regular, monospace;
            font-size: 12px;
        }

        .activity-meta {
            margin-top: 6px;
            display: flex;
            gap: 12px;
            font-size: 11px;
            color: var(--text-muted);
        }

        .activity-details {
            display: none;
            margin-top: 12px;
            padding: 12px;
            background: var(--bg-tertiary);
            border-radius: 6px;
            font-size: 12px;
        }

        .detail-section {
            margin-bottom: 12px;
        }

        .detail-section:last-child {
            margin-bottom: 0;
        }

        .detail-label {
            color: var(--text-muted);
            margin-bottom: 4px;
            font-weight: 500;
        }

        .detail-content {
            background: var(--bg-primary);
            padding: 8px;
            border-radius: 4px;
            font-family: ui-monospace, SFMono-Regular, monospace;
            white-space: pre-wrap;
            word-break: break-all;
            max-height: 200px;
            overflow-y: auto;
        }

        .btn {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: background 0.15s;
        }

        .btn:hover {
            background: var(--border);
        }

        .btn-primary {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
        }

        .btn-primary:hover {
            background: #4c8ed9;
        }

        .btn-small {
            padding: 4px 8px;
            font-size: 11px;
        }

        select, input {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 13px;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--accent-blue);
        }

        input::placeholder {
            color: var(--text-muted);
        }

        .filter-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-top: 8px;
        }

        .filter-chip {
            background: var(--bg-tertiary);
            border: 1px solid var(--border);
            padding: 4px 10px;
            border-radius: 16px;
            font-size: 11px;
            cursor: pointer;
            transition: all 0.15s;
        }

        .filter-chip:hover {
            border-color: var(--accent-blue);
        }

        .filter-chip.active {
            background: rgba(88, 166, 255, 0.2);
            border-color: var(--accent-blue);
            color: var(--accent-blue);
        }

        .empty-state {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-secondary);
        }

        .success-badge {
            color: var(--accent-green);
        }

        .error-badge {
            color: var(--accent-red);
        }

        .duration-badge {
            color: var(--text-muted);
            font-size: 11px;
        }

        /* Tool call spinner animation */
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .spinner {
            display: inline-block;
            width: 12px;
            height: 12px;
            border: 2px solid var(--text-muted);
            border-top-color: var(--accent-purple);
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
            vertical-align: middle;
        }

        .tool-call-pending .activity-type-icon {
            background: var(--accent-yellow);
        }

        .stream-status-bar {
            padding: 6px 16px;
            font-size: 11px;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 8px;
            min-height: 28px;
        }

        .hydrating-indicator {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            color: var(--accent-yellow);
        }

        @media (max-width: 1000px) {
            .grid {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Squadron Dashboard</h1>
            <div class="status-indicator">
                <span class="status-dot" id="connectionStatus"></span>
                <span id="connectionText">Disconnected</span>
            </div>
        </header>

        <div class="controls-bar">
            <div class="control-group">
                <input type="password" id="apiKey" placeholder="API Key (if required)" style="width: 200px;">
                <button class="btn btn-primary" onclick="connect()">Connect</button>
                <button class="btn" onclick="disconnect()">Disconnect</button>
            </div>
            <div class="control-group">
                <label>Event Types:</label>
                <select id="eventTypeFilter" multiple style="min-width: 200px; height: 32px;">
                    <option value="">All Events</option>
                    <optgroup label="Agent Lifecycle">
                        <option value="agent_spawned">Agent Spawned</option>
                        <option value="agent_woke">Agent Woke</option>
                        <option value="agent_sleeping">Agent Sleeping</option>
                        <option value="agent_completed">Agent Completed</option>
                        <option value="agent_escalated">Agent Escalated</option>
                        <option value="agent_failed">Agent Failed</option>
                    </optgroup>
                    <optgroup label="Tool Execution">
                        <option value="tool_call_start">Tool Call</option>
                        <option value="tool_call_end">Tool Call Result</option>
                    </optgroup>
                    <optgroup label="LLM Interaction">
                        <option value="reasoning">Reasoning</option>
                        <option value="user_message">User Message</option>
                    </optgroup>
                    <optgroup label="GitHub Operations">
                        <option value="github_comment">GitHub Comment</option>
                        <option value="github_pr_opened">GitHub PR Opened</option>
                        <option value="github_review">GitHub Review</option>
                        <option value="github_issue_created">GitHub Issue Created</option>
                    </optgroup>
                    <optgroup label="System Events">
                        <option value="error">Error</option>
                        <option value="warning">Warning</option>
                        <option value="info">Info</option>
                        <option value="circuit_breaker_warning">Circuit Breaker Warning</option>
                        <option value="circuit_breaker_triggered">Circuit Breaker Triggered</option>
                    </optgroup>
                </select>
            </div>
        </div>

        <div class="filter-chips" id="activeFilters"></div>

        <div class="grid" style="margin-top: 16px;">
            <div class="panel">
                <div class="panel-header">
                    Agents
                    <button class="btn btn-small" onclick="refreshAgents()">Refresh</button>
                </div>
                <div class="agent-item" onclick="selectAgent(null)" id="allAgentsOption" style="border-bottom: 2px solid var(--border);">
                    <div class="agent-header">
                        <span class="agent-id">All Agents</span>
                    </div>
                    <div class="agent-meta">Show events from all agents</div>
                </div>
                <ul class="agent-list" id="agentList">
                    <li class="empty-state">Connect to view agents</li>
                </ul>
            </div>

            <div class="panel">
                <div class="panel-header" style="border-bottom: none;">
                    <span id="streamInfo">Activity Stream</span>
                    <button class="btn btn-small" onclick="clearFeed()">Clear</button>
                </div>
                <!-- Stream status bar: shows hydration progress or live status -->
                <div class="stream-status-bar" id="streamStatusBar">
                    <span id="streamStatusText">Not connected</span>
                </div>
                <div class="activity-feed" id="activityFeed">
                    <div class="empty-state">Connect to view activity</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        let eventSource = null;
        let selectedAgent = null;
        let selectedEventTypes = [];
        // Tracks pending tool_call_start items awaiting their tool_call_end.
        // Key: "${agent_id}:${tool_name}", Value: array of DOM element references (FIFO)
        const pendingToolCalls = {};
        // Whether we are still receiving history events (before 'hydrated' signal)
        let isHydrating = false;

        function getApiKey() {
            return document.getElementById('apiKey').value || null;
        }

        function getBaseUrl() {
            return window.location.origin;
        }

        function connect() {
            disconnect();
            resetPendingToolCalls();

            const apiKey = getApiKey();
            const baseUrl = getBaseUrl();
            let url = selectedAgent
                ? `${baseUrl}/dashboard/agents/${selectedAgent}/stream`
                : `${baseUrl}/dashboard/stream`;

            if (apiKey) {
                url += `?token=${encodeURIComponent(apiKey)}`;
            }

            eventSource = new EventSource(url);
            isHydrating = true;

            eventSource.addEventListener('connected', (e) => {
                updateConnectionStatus(true);
                updateStreamStatus('hydrating');
                refreshAgents();
            });

            eventSource.addEventListener('activity', (e) => {
                const event = JSON.parse(e.data);
                // Apply client-side event type filter.
                // For tool_call_end we check against 'tool_call_start' as well since
                // they are presented as a single merged UI element.
                const passesFilter = selectedEventTypes.length === 0
                    || selectedEventTypes.includes(event.event_type)
                    || (event.event_type === 'tool_call_end' && selectedEventTypes.includes('tool_call_start'));
                if (passesFilter) {
                    handleActivityEvent(event);
                }
            });

            eventSource.addEventListener('hydrated', () => {
                isHydrating = false;
                updateStreamStatus('live');
            });

            eventSource.addEventListener('heartbeat', () => {
                updateConnectionStatus(true);
            });

            eventSource.onerror = () => {
                updateConnectionStatus(false);
                updateStreamStatus('disconnected');
            };

            updateStreamInfo();
        }

        function disconnect() {
            if (eventSource) {
                eventSource.close();
                eventSource = null;
            }
            isHydrating = false;
            updateConnectionStatus(false);
            updateStreamStatus('disconnected');
        }

        function resetPendingToolCalls() {
            for (const key in pendingToolCalls) {
                delete pendingToolCalls[key];
            }
        }

        function updateConnectionStatus(connected) {
            const dot = document.getElementById('connectionStatus');
            const text = document.getElementById('connectionText');

            if (connected) {
                dot.classList.add('connected');
                text.textContent = 'Connected';
            } else {
                dot.classList.remove('connected');
                text.textContent = 'Disconnected';
            }
        }

        function updateStreamStatus(state) {
            const bar = document.getElementById('streamStatusBar');
            const text = document.getElementById('streamStatusText');
            bar.innerHTML = '';

            if (state === 'hydrating') {
                bar.innerHTML = `
                    <span class="hydrating-indicator">
                        <span class="spinner"></span>
                        Loading history&hellip;
                    </span>`;
            } else if (state === 'live') {
                text.textContent = 'â— Live';
                text.style.color = 'var(--accent-green)';
                bar.appendChild(text);
            } else {
                text.textContent = 'Not connected';
                text.style.color = '';
                bar.appendChild(text);
            }
        }

        function updateStreamInfo() {
            const info = document.getElementById('streamInfo');
            let text = selectedAgent ? `Stream: ${selectedAgent}` : 'Activity Stream';
            if (selectedEventTypes.length > 0) {
                text += ` | ${selectedEventTypes.length} filter(s)`;
            }
            info.textContent = text;
        }

        async function refreshAgents() {
            const apiKey = getApiKey();
            const baseUrl = getBaseUrl();

            try {
                const headers = {};
                if (apiKey) {
                    headers['Authorization'] = `Bearer ${apiKey}`;
                }

                const response = await fetch(`${baseUrl}/dashboard/agents`, { headers });
                if (!response.ok) throw new Error(`HTTP ${response.status}`);

                const data = await response.json();
                renderAgentList(data.active_agents, data.recent_agents);
            } catch (error) {
                console.error('Failed to fetch agents:', error);
                document.getElementById('agentList').innerHTML =
                    '<li class="empty-state">Failed to load agents</li>';
            }
        }

        function renderAgentList(activeAgents, recentAgents) {
            const list = document.getElementById('agentList');
            const allOption = document.getElementById('allAgentsOption');

            allOption.className = selectedAgent === null ? 'agent-item selected' : 'agent-item';

            const agents = [...(activeAgents || []), ...(recentAgents || [])];
            const seen = new Set();
            const uniqueAgents = agents.filter(a => {
                if (seen.has(a.agent_id)) return false;
                seen.add(a.agent_id);
                return true;
            });

            if (uniqueAgents.length === 0) {
                list.innerHTML = '<li class="empty-state">No agents found</li>';
                return;
            }

            list.innerHTML = uniqueAgents.map(agent => `
                <li class="agent-item ${selectedAgent === agent.agent_id ? 'selected' : ''}"
                    onclick="selectAgent('${agent.agent_id}')">
                    <div class="agent-header">
                        <span class="agent-id">${agent.agent_id}</span>
                        <span class="agent-status status-${agent.status}">${agent.status}</span>
                    </div>
                    <div class="agent-meta">
                        ${agent.role} | Issue #${agent.issue_number || 'N/A'}
                        ${agent.tool_call_count ? ` | ${agent.tool_call_count} tool calls` : ''}
                    </div>
                </li>
            `).join('');
        }

        function selectAgent(agentId) {
            selectedAgent = agentId;
            refreshAgents();
            if (eventSource) {
                // Reconnect so we get history for the selected agent
                clearFeed();
                connect();
            }
        }

        // Event type filtering
        document.getElementById('eventTypeFilter').addEventListener('change', function(e) {
            selectedEventTypes = Array.from(this.selectedOptions)
                .map(opt => opt.value)
                .filter(v => v !== '');

            updateFilterChips();
            updateStreamInfo();
        });

        function updateFilterChips() {
            const container = document.getElementById('activeFilters');
            if (selectedEventTypes.length === 0) {
                container.innerHTML = '';
                return;
            }

            container.innerHTML = selectedEventTypes.map(type => `
                <span class="filter-chip active" onclick="removeFilter('${type}')">
                    ${formatEventType(type)} Ã—
                </span>
            `).join('');
        }

        function removeFilter(type) {
            selectedEventTypes = selectedEventTypes.filter(t => t !== type);
            const select = document.getElementById('eventTypeFilter');
            Array.from(select.options).forEach(opt => {
                if (opt.value === type) opt.selected = false;
            });
            updateFilterChips();
            updateStreamInfo();
        }

        // â”€â”€ Activity Feed â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

        /**
         * Route an activity event to the appropriate handler.
         *
         * tool_call_start events create a pending Tool Call item (spinner).
         * tool_call_end events look for a matching pending item and update it
         * (spinner â†’ check/cross) so both events share a single UI element.
         * All other events are rendered directly.
         */
        function handleActivityEvent(event) {
            if (event.event_type === 'tool_call_start') {
                addToolCallStartItem(event);
            } else if (event.event_type === 'tool_call_end') {
                mergeToolCallResult(event);
            } else {
                addActivityItem(event);
            }
        }

        /**
         * Add a pending Tool Call item with a spinner.
         * The item is stored in pendingToolCalls so the matching
         * tool_call_end can update it later.
         */
        function addToolCallStartItem(event) {
            const feed = document.getElementById('activityFeed');
            removeEmptyState(feed);

            const item = document.createElement('div');
            item.className = 'activity-item tool-call-pending';
            item.dataset.agentId = event.agent_id;
            item.dataset.toolName = event.tool_name || '';

            const time = formatTimestamp(event.timestamp);

            item.innerHTML = buildToolCallPendingHTML(event, time);

            feed.insertBefore(item, feed.firstChild);
            trimFeed(feed);

            // Register as pending so tool_call_end can find it
            const key = pendingToolCallKey(event.agent_id, event.tool_name);
            if (!pendingToolCalls[key]) {
                pendingToolCalls[key] = [];
            }
            pendingToolCalls[key].push(item);
        }

        /**
         * Find the oldest pending tool call item for this result and update it
         * in-place: replace spinner with check/cross and add result details.
         * If no matching pending item exists (e.g. page loaded mid-stream),
         * fall back to rendering a standalone completed item.
         */
        function mergeToolCallResult(event) {
            const key = pendingToolCallKey(event.agent_id, event.tool_name);
            const queue = pendingToolCalls[key];

            if (queue && queue.length > 0) {
                // FIFO: the oldest pending start matches this result
                const item = queue.shift();
                if (queue.length === 0) {
                    delete pendingToolCalls[key];
                }
                updateToolCallItem(item, event);
            } else {
                // No matching start found â€” render as a completed item directly
                addCompletedToolCallItem(event);
            }
        }

        function pendingToolCallKey(agentId, toolName) {
            return `${agentId}:${toolName || ''}`;
        }

        /**
         * Build the inner HTML for a pending (spinner) tool call item.
         */
        function buildToolCallPendingHTML(event, time) {
            const argsDetails = event.tool_args
                ? `<div class="detail-section">
                       <div class="detail-label">Tool Arguments</div>
                       <div class="detail-content">${escapeHtml(JSON.stringify(event.tool_args, null, 2))}</div>
                   </div>`
                : '';

            return `
                <div class="activity-header" onclick="toggleDetails(this)">
                    <span class="activity-type">
                        <span class="activity-type-icon icon-tool">T</span>
                        Tool Call
                    </span>
                    <span class="activity-time">${time}</span>
                </div>
                <div class="activity-summary">
                    <code>${escapeHtml(event.tool_name || '')}</code>
                    <span class="spinner" title="Awaiting result"></span>
                </div>
                <div class="activity-meta">
                    <span>Agent: ${escapeHtml(event.agent_id)}</span>
                    ${event.issue_number ? `<span>Issue: #${event.issue_number}</span>` : ''}
                    ${event.pr_number ? `<span>PR: #${event.pr_number}</span>` : ''}
                </div>
                ${argsDetails ? `<div class="activity-details">${argsDetails}</div>` : ''}
            `;
        }

        /**
         * Update an existing pending tool call item in-place with result data.
         * Replaces the spinner with a success/failure badge and appends result
         * details to the expandable section.
         */
        function updateToolCallItem(item, resultEvent) {
            item.classList.remove('tool-call-pending');

            const successBadge = resultEvent.tool_success === true
                ? '<span class="success-badge" title="Success">âœ“</span>'
                : resultEvent.tool_success === false
                    ? '<span class="error-badge" title="Failed">âœ— FAILED</span>'
                    : '';

            const durationBadge = resultEvent.tool_duration_ms
                ? `<span class="duration-badge">(${resultEvent.tool_duration_ms}ms)</span>`
                : '';

            // Update summary: remove spinner, add result badges
            const summary = item.querySelector('.activity-summary');
            if (summary) {
                summary.innerHTML = `
                    <code>${escapeHtml(resultEvent.tool_name || '')}</code>
                    ${durationBadge}
                    ${successBadge}
                `;
            }

            // Append result to details section
            if (resultEvent.tool_result) {
                let details = item.querySelector('.activity-details');
                if (!details) {
                    details = document.createElement('div');
                    details.className = 'activity-details';
                    item.appendChild(details);
                }
                const resultSection = document.createElement('div');
                resultSection.className = 'detail-section';
                resultSection.innerHTML = `
                    <div class="detail-label">Tool Result</div>
                    <div class="detail-content">${escapeHtml(resultEvent.tool_result)}</div>
                `;
                details.appendChild(resultSection);
            }
        }

        /**
         * Render a completed tool call as a single item (fallback when no
         * matching start was found â€” e.g. loaded mid-stream or from history).
         */
        function addCompletedToolCallItem(event) {
            const feed = document.getElementById('activityFeed');
            removeEmptyState(feed);

            const item = document.createElement('div');
            item.className = 'activity-item';

            const time = formatTimestamp(event.timestamp);
            const successBadge = event.tool_success === true
                ? '<span class="success-badge">âœ“</span>'
                : event.tool_success === false
                    ? '<span class="error-badge">âœ— FAILED</span>'
                    : '';
            const durationBadge = event.tool_duration_ms
                ? `<span class="duration-badge">(${event.tool_duration_ms}ms)</span>`
                : '';

            let details = '';
            if (event.tool_args) {
                details += `<div class="detail-section">
                    <div class="detail-label">Tool Arguments</div>
                    <div class="detail-content">${escapeHtml(JSON.stringify(event.tool_args, null, 2))}</div>
                </div>`;
            }
            if (event.tool_result) {
                details += `<div class="detail-section">
                    <div class="detail-label">Tool Result</div>
                    <div class="detail-content">${escapeHtml(event.tool_result)}</div>
                </div>`;
            }

            item.innerHTML = `
                <div class="activity-header" onclick="toggleDetails(this)">
                    <span class="activity-type">
                        <span class="activity-type-icon icon-tool">T</span>
                        Tool Call
                    </span>
                    <span class="activity-time">${time}</span>
                </div>
                <div class="activity-summary">
                    <code>${escapeHtml(event.tool_name || '')}</code>
                    ${durationBadge}
                    ${successBadge}
                </div>
                <div class="activity-meta">
                    <span>Agent: ${escapeHtml(event.agent_id)}</span>
                    ${event.issue_number ? `<span>Issue: #${event.issue_number}</span>` : ''}
                    ${event.pr_number ? `<span>PR: #${event.pr_number}</span>` : ''}
                </div>
                ${details ? `<div class="activity-details">${details}</div>` : ''}
            `;

            feed.insertBefore(item, feed.firstChild);
            trimFeed(feed);
        }

        /**
         * Render a non-tool-call activity item.
         */
        function addActivityItem(event) {
            const feed = document.getElementById('activityFeed');
            removeEmptyState(feed);

            const item = document.createElement('div');
            item.className = 'activity-item';

            const iconClass = getIconClass(event.event_type);
            const time = formatTimestamp(event.timestamp);

            let summary = '';
            if (event.tool_name) {
                summary = `<code>${escapeHtml(event.tool_name)}</code>`;
            } else if (event.content) {
                const truncated = event.content.length > 150
                    ? event.content.substring(0, 150) + '...'
                    : event.content;
                summary = escapeHtml(truncated);
            }

            let details = '';
            if (event.tool_args) {
                details += `<div class="detail-section">
                    <div class="detail-label">Tool Arguments</div>
                    <div class="detail-content">${escapeHtml(JSON.stringify(event.tool_args, null, 2))}</div>
                </div>`;
            }
            if (event.tool_result) {
                details += `<div class="detail-section">
                    <div class="detail-label">Tool Result</div>
                    <div class="detail-content">${escapeHtml(event.tool_result)}</div>
                </div>`;
            }
            if (event.content && event.content.length > 150) {
                details += `<div class="detail-section">
                    <div class="detail-label">Full Content</div>
                    <div class="detail-content">${escapeHtml(event.content)}</div>
                </div>`;
            }
            if (event.metadata && Object.keys(event.metadata).length > 0) {
                details += `<div class="detail-section">
                    <div class="detail-label">Metadata</div>
                    <div class="detail-content">${escapeHtml(JSON.stringify(event.metadata, null, 2))}</div>
                </div>`;
            }

            item.innerHTML = `
                <div class="activity-header" onclick="toggleDetails(this)">
                    <span class="activity-type">
                        <span class="activity-type-icon ${iconClass}">${getIcon(event.event_type)}</span>
                        ${formatEventType(event.event_type)}
                    </span>
                    <span class="activity-time">${time}</span>
                </div>
                <div class="activity-summary">${summary}</div>
                <div class="activity-meta">
                    <span>Agent: ${escapeHtml(event.agent_id)}</span>
                    ${event.issue_number ? `<span>Issue: #${event.issue_number}</span>` : ''}
                    ${event.pr_number ? `<span>PR: #${event.pr_number}</span>` : ''}
                </div>
                ${details ? `<div class="activity-details">${details}</div>` : ''}
            `;

            feed.insertBefore(item, feed.firstChild);
            trimFeed(feed);
        }

        // â”€â”€ History: replay paired tool_call_start+end events â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        //
        // When history is replayed the events arrive in chronological order.
        // tool_call_start events are added with a spinner; the matching
        // tool_call_end follows shortly after and merges in the same way as
        // live events.  After hydration the pendingToolCalls map is cleared so
        // stale pending items (tool_call_start without a matching end, e.g. an
        // in-progress call that pre-dates this page load) stay as spinners
        // rather than polluting future live events.
        eventSource && document.addEventListener('hydrated', () => {
            resetPendingToolCalls();
        });

        function toggleDetails(header) {
            const item = header.closest('.activity-item');
            item.classList.toggle('expanded');
        }

        function removeEmptyState(feed) {
            const emptyState = feed.querySelector('.empty-state');
            if (emptyState) emptyState.remove();
        }

        function trimFeed(feed) {
            // Keep only the most recent 500 items to avoid memory bloat
            while (feed.children.length > 500) {
                feed.removeChild(feed.lastChild);
            }
        }

        function formatTimestamp(isoString) {
            const d = new Date(isoString);
            return `${d.toLocaleDateString()} ${d.toLocaleTimeString()}`;
        }

        function getIconClass(eventType) {
            if (eventType.includes('tool_call')) return 'icon-tool';
            if (eventType.includes('agent_')) return 'icon-lifecycle';
            if (eventType.includes('github_')) return 'icon-github';
            if (eventType.includes('circuit_breaker')) return 'icon-circuit';
            if (eventType === 'error') return 'icon-error';
            if (eventType === 'warning') return 'icon-circuit';
            if (eventType === 'reasoning') return 'icon-reasoning';
            if (eventType === 'info') return 'icon-info';
            return 'icon-lifecycle';
        }

        function getIcon(eventType) {
            if (eventType.includes('tool_call')) return 'T';
            if (eventType === 'agent_spawned') return '+';
            if (eventType === 'agent_completed') return 'âœ“';
            if (eventType === 'agent_failed') return 'âœ—';
            if (eventType === 'agent_escalated') return '!';
            if (eventType.includes('agent_')) return 'A';
            if (eventType.includes('github_')) return 'G';
            if (eventType.includes('circuit_breaker')) return 'âš¡';
            if (eventType === 'error') return 'E';
            if (eventType === 'warning') return 'âš ';
            if (eventType === 'reasoning') return 'ðŸ’­';
            if (eventType === 'info') return 'i';
            return 'â€¢';
        }

        function formatEventType(type) {
            return type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }

        function escapeHtml(text) {
            if (typeof text !== 'string') return String(text);
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function clearFeed() {
            document.getElementById('activityFeed').innerHTML =
                '<div class="empty-state">Activity events will appear here</div>';
            resetPendingToolCalls();
        }

        // Auto-connect if no API key is required
        window.addEventListener('load', () => {
            fetch(`${getBaseUrl()}/dashboard/status`)
                .then(r => r.json())
                .then(data => {
                    if (!data.security?.authentication_required) {
                        connect();
                    }
                })
                .catch(() => {});
        });
    </script>
</body>
</html>
